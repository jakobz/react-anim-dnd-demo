Привет! 

[SLIDE: Title]

Меня зовут Яша Жмуров, я занимаюсь внутренними приложениями Grow, Learn, и несколькими еще вокруг.
Сегодня я расскажу про анимации, драг-н-дроп, и подход с написанием CSS в JavaScript. Так получилось, что все три этих штуки мы много используем, так что по дороге я поделюсь нашим опытом.
Поехали.

[SLIDE: Animations UX - links, funny example]

Начнем сначала с анимаций.

Прежде всего, для чего вообще анимации нужны. Разрабочики часто пропускают эту тему. Дизайнеры дают им картинку из фотошопа. На картинке нет анимаций.
И программист такой - о, я ща сделаю чтобы там пыщ-пыщь вжик-вжик вон та фигня ездила. Ну, чтобы все поняли, какой я ловкий и умелый.

Времена когда само наличие анимации выглядело круто - прошли.
Прежде чем делать анимации - убедитесь что вы не делаете шедевр в стиле "смотрите как я умею".

Как минимум, я советую посмотреть сайт Material Design. Там хорошо разложено. Тем более, material design нынче моден.
https://material.io/guidelines/motion/material-motion.html
Общие рекомендации примерно такие:
- сходите лучше к дизайнеру, пусть он расскажет где надо вжик-вжик, и как оно должно работать
- анимация не должна быть чисто для украшения. Она должна помогать пользователю - понять что куда уехало, или что произойдет если я вон ту штуковину потяну.
- полезно пользоваться метафорами - вот тут листик бумаги приподнялся, и под него заехал другой листик - от этого появилась малюююсенькая тень на стыке.
А вон та штука выщелкивается наружу невидимой пружиной. Она тяжелая, поэтому медленно разгоняется, и потом бам - ударяется в другую штуку, и резко останавливается.
- Но все равно лучше сходите к дизайнеру
- Но убедитесь что дизайнер понимает как анимации работают, и что задуманное им вообще можно сделать.
Например, люди часто не понимают что нельзя анимировать ширину блока с текстом. Текст переносится по словам, и если тянуть блок с ним - получается треш и угар.
Кроме того, есть чисто технические сложности, от которых лучше отмазаться сразу, чем стоять потом потупив взор за день до дедлайна.

[SLIDE: CSS Animation Approaches - 3 bullets, small code examples]

Теперь о техниках.

Есть три техники делать анимации:
- CSS Animations. Специальным синтаксисом в CSS указываем ключевые кадры:
[TBD: example]
Потом в вешаем класс на элемент (сразу при появлении, или динамически) - и оно полетело.

CSS Animations, не смотря на название, как-то не очень хорошо заходит.
Чаше всего анимируются переходы между состояними, а не какое-то "полетели влево, потом вправо, и так по кругу". А для переходов между состояними, CSS Transitions куда удобнее
Ну и просто там какой-то дурацкий синтаксис этот, надо знать все значения в keyframe-ах заранее.
Я посмотрел по проекту - по делу у нас на них только AJAX-крутилки сделаны - вот там оно в тему.
Короче про CSS Animations знать полезно, и местами они в тему, но давайте дальше.

Есть еще вариант с анимациями в JS. Я, лично, ничего против не имею - в каких-нибудь сложных штуках может быть применимо. Но если можно проще - зачем усложнять.

[SLIDE: CSS Transitions]

Давайте перейдем к CSS Transitions. Это самый ходовой подход.

Чтобы заработали Transitions, надо в CSS написать 
transition: all 0.2s ease;

All - это какие CSS-свойства анимировать. Это может быть, например, width. Но чаще всего меняется одно-два свойства, а остальные - вообще не меняются. В таких случаях all достаточно.
Если нужно что-то не анимировать, или задать раные настройки для разных свойств - тогда уже стоит написать какие именно свойства будем менять плавно.
0.2s - время анимации. Помним что анимация должна подчеркивать UX, а не заставлять юзера биться в конвульсиях типа "когда оно уже доедет". Значения больше 0.2s - плохой звоночек.
Если написали больше 0.2s - попросите соседя по парте понажимать, и убедитесь что на 10-й раз он не будет стучать мышкой по вашей клавиатуре.

ease - кривая анимации. Можно поиграться тут:
https://matthewlein.com/ceaser/
Кривая сильно влияет на ощущения - либо будет приятно щелкаться, либо будет ощущаться как что-то неприятное трогаешь.
Значение по-умолчанию - ease, часто неплохо подходит.
Выберите метафору: переключатель с пружинкой - ease, ease-out или даже ease-out-cubic.
Элемент отваливается, падает вниз - ease-in.
На том же material design неплохо описано где какой использовать.

В принципе, часто достаточно этой одной строчки с transition, и анимация уже работает. Скажем, чтобы анимировать :hover, больше ничего и не надо.
Но есть тонкости.

[Enter/Leave transitions]
Тонкость №1. Например, мы хотим чтобы элемент появлялся и исчезал плавно изменяя opacity с 0 до 100%.
Мы вешаем transition на opacity, но ничего не происходит - мы же сразу его рисуем с opacity 100%, а когда он исчезает - мы его еще и сразу убираем из DOM, не давая вообще шансов куда-то плавно пропасть.
Поэтому техника примерно такая:
- делаем такой CSS:

[example here]
<div class='appear'/> // тут он прозрачный, т

- Render #1 - рисуем элемент так. Тут он прозрачный, т.к. на нем висит класс appear, а в нем opacity: 0
- сразу же делаем Render #2 - и рисуем тот же элемент вот так. Тут он уже непрозрачный, и начинается transition
- дальше элемент сколько хочет живет, и мы решаем его закрыть. 
- делаем Render #3 - рисуем его сначала с классом ТТТТТТ
- ждем сколько-нибудь (как минимум сколько длится transition, но если больше - ничего страшного), и уже окончательно сносим этот div.

К слову, если элемент не успеет до конца появиться, а мы его уже убираем - все равно все будет плавненько, просто он не до конца появится.

Для этого подхода когда-то была удобняшка в самом react-е, теперь ее вынесли в библиотеку
https://github.com/reactjs/react-transition-group

Вот как окучивается пример выше, с использованием этой либы:
[react-transition-group example]

В принципе, тут мы просто передаем какие классы навешивать, и оно реализует алгоритм, описанный выше. 
Библиотечка маленькая, хорошо работает, можно смело брать.

[SLIDE: tips]

- иногда полезно давать задержку на старт появления или исчезновения элемента.
Например, можно повесить на появление тултипа, чтобы не вызвать ненужного моргания, если мышка случайно задела элемент.
Или дать шанс действию по загрузке чего-либо выполнится, перед тем как мы начнем чем-либо моргать.

- на transition можно делать весьма сложные штуки, например я календарь в Grow сделал чисто на transitions-ах
Правда, там приходится добавлять и удалять невидимые элементы, т.к. шкала времени бесконечна в обе стороны, и нельзя нарисовать ее всю.
Но в целом все просто - считаем координаты элементов, исходя из их даты и текущей позиции и масштаба,
рисуем их с position: absolute и вычисленными координатами, вешаем transition - и вот оно уже плавненько у нас все ездит.

[SLIDE]

Во-пе